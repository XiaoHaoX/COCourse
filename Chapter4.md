---
title: 第四章
description: 好家伙
---

# 第4章 存储器

### 本章概述

本章重点介绍存储器的分类、工作原理、组成方式以及其他部件（如CPU）的联系。此处还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。旨在使读者真正建立起如何用的存储器组成具有层次结构的存储系统的概念。

## 4.1 概述

### 4.1.1 存储器分类

1、按存储介质分类

（1）半导体存储器

由半导体器件组成的存储器。

- 优点：体积小、功耗低、存取时间短
- 缺点：当电源消失时，所存信息也随之丢失，是一种易失性存储器。

按其材料不同又可分为双极型（TTL）半导体存储器（特点：高速）和MOS半导体存储器（特点：高集成度，制造简单，成本低廉，功耗小，广泛应用）。

（2）磁表面存储器

在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随**载磁体**高速运转，用**磁头**在磁层上进行读/写操作。

特点：非易失性。

> 按载磁体形状的不同，可分为磁盘、磁带和磁鼓。

（3）磁芯存储器

磁芯是由**硬磁材料**做成的**环形元件**，在磁芯中穿有驱动线（通电流）和读出线，这样便可以进行读/写操作。

特点：非易失性。体积过大、工艺复杂、功耗太大，目前几乎已不采用。

（4）光盘存储器

是应用**激光**在记录介质（**磁光材料**）上进行读/写的存储器。

特点：非易失性。记录密度高、耐用性好、可靠性高、可互换性强，越来越用于计算机系统。

2、按存取方式分类

（1）随机存储器（RAM）

在程序的执行过程中**可读可写**。存储器的任何一个存储单元的内容都可以随机存取，存取时间与存取单元的物理位置无关。

（2）只读存储器（ROM）

在程序的执行过程中**只读**。通常存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。与随机存储器可共同作为主存的一部分，统一构成主存的地址域。

（3）串行访问存储器

对存储单元进行读/写操作时，按其物理位置的先后顺序寻找地址。这种存储器由于信息所在位置不同，使得读/写时间均不相同。

- 顺序存取存储器：不论信息处在哪个位置，读/写时必须从其介质的始端开始按顺序寻找，如磁带。
- 直接存取存储器：在对磁盘读/写时，首先直接指出该存储器中的某个小区域（磁道），然后再顺序寻访，直至找到位置，如磁盘。

3、按在计算机中的作用分类

主存储器（简称主存）：可以和CPU直接交换信息。

辅助存储器（简称辅存）：是主存的后援存储器，用来存放当前暂时不用的程序和数据，不能直接和CPU交换信息。

> 二者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。

缓冲存储器（简称缓存）：用在两个速度不同的部件之中，起到缓冲作用。

综上所述，存储器分类如下图：

![img](https://s2.ax1x.com/2019/11/12/M8ly01.png)

### 4.1.2 存储器的层次结构

1、存储器三个主要特性的关系

存储器有3个主要性能指标：速度、容量和每位价格（简称位价）。

下图反映了三者的关系。图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU访问的频度越来越少。

![img](https://s2.ax1x.com/2019/11/12/M81E3F.png)

2、缓存 — 主存层次和主存 — 辅存层次

实际上，存储系统层次结构主要体现在缓存 — 主存和主存 — 辅存这两个存储层次上。如下图所示。

![img](https://s2.ax1x.com/2019/11/12/M81HKJ.png)

> 缓存 — 主存层次主要解决CPU和主存速度不匹配的问题。

主存 — 辅存层次主要解决存储系统的容量问题。

## 4.2 主存储器

### 4.2.1 概述

1、主存的基本组成

![img](https://s2.ax1x.com/2019/11/12/M83rIx.png)

2、主存与CPU的联系

如下图所示，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接。

![img](https://s2.ax1x.com/2019/11/12/M83zoq.png)

3、主存中存储单元地址的分配

主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号，根据该地址可读出或写入一个存储字。

不同的机器存储字长不同。

8位二进制数表示一个字节，存储字长都取8的倍数。

4、主存的技术指标

（1）存储容量

指主存能存放二进制代码的总位数，即 **存储容量=存储单元个数×存储字长**

它的容量也可用字节总数来表示，即 **存储容量=存储单元个数×存储字长/8**

（2）存储速度

- 存储时间（又称存储器的访问时间）：指启动一次存储器操作（读或写）到完成该操作所需的全部时间。

> 分为读出时间（从存储器接收到有效地址开始，到产生有效输出所需的全部时间）和写入时间（从存储器接收到有效地址开始，到数据写入被选中单元为止所需的全部时间）。
>
> - 存储周期：指存储器进行连续两次独立的存储器操作（如连续两次读操作）所需的最小间隔时间，通常存取周期大于存取时间。

（3）存储器带宽

表示单位时间内存储器存取的信息量，单位可用**字/秒**或**字节/秒**或**位/秒**表示。

提高存储器带宽的措施：

- 缩短存取周期
- 增加存储字长，使每个存取周期可读/写更多的二进制位数。
- 增加存储体

### 4.2.2 半导体存储芯片的简介

1、半导体存储芯片的基本结构

**译码驱动**能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作。

**读/写电路**包括读出放大器和写入电路，用来完成读/写操作。

**存储芯片**通过地址总线、数据总线和控制总线与外部连接。

下图为存储芯片的基本结构

![img](https://s2.ax1x.com/2019/11/14/MtyY40.png)

**地址线**是单向输入的，其位数与芯片容量有关。

**数据线**是双向的，其位数与芯片可读出或写入的数据位数有关。数据线的位数与芯片容量有关。

地址线和数据线的位数共同反应存储芯片的容量。

**控制线**主要有读/写控制线和片选线两种。

存储芯片片选线的作用：用16K×1位的存储芯片组成64K×8位的存储器

![img](https://s2.ax1x.com/2019/11/14/Mt6jW6.png)

2、半导体存储芯片的译码驱动方式

（1）线选法

下图是一个16×1字节线选法存储芯片的结构示意图。特点是用一根字选择线（字线），直接选中一个存储单元的各位。结构简单，只适用于容量不大的存储芯片。

![img](https://s2.ax1x.com/2019/11/14/Mtc4AA.png)

（2）重合法

下图是一个1K×1位重合法结构示意图。

![img](https://s2.ax1x.com/2019/11/14/MtgsEj.png)

### 4.2.3 随机存取存储器

随机存取存储器按其存储信息的原理不同，可分为静态RAM和动态RAM两大类。

1、静态RAM（SRAM）

（1）静态RAM基本单元电路

![img](https://s2.ax1x.com/2019/11/14/Mt2PPI.png)

Tp1~T4 触发器

T5、T6 行开关

T7、T8 列开关，一列共用

A 触发器原端

A` 触发器非端

//静态RAM属于易失性半导体存储器

（2）静态RAM芯片举例

Intel2114芯片

下图为Intel2114外特性示意图

![img](https://s2.ax1x.com/2019/11/14/MtWxqU.png)

下图为2114芯片结构示意图

![img](https://s2.ax1x.com/2019/11/14/MtfceU.png)

下图为2114RAM芯片内的存储矩阵结构

![img](https://s2.ax1x.com/2019/11/14/MthJpR.png)

//详细图解见课本76-79页

（3）静态RAM读/写时序

1）读周期时序

![img](https://s2.ax1x.com/2019/11/14/MthgjP.png)

2）写周期时序

![img](https://s2.ax1x.com/2019/11/14/Mt4sVU.png)

//详细过程解析见课本78-80页

2、动态RAM（DRAM）

（1）动态RAM的基本单元电路

常见的动态RAM基本单元电路靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。

再生或刷新：电容上的电荷一般只能维持1~2ms。因此即使电源不掉电，信息也会丢失，为此，必须在2ms内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。

下图为三管MOS动态RAM基本单元电路。

![img](https://s2.ax1x.com/2019/11/14/MtInXt.png)

为了提高集成度，将三管电路进一步简化，得到单管MOS动态RAM基本单元电路，如下图。

![img](https://s2.ax1x.com/2019/11/14/MtI639.png)

（2）动态RAM芯片举例

1）三管动态RAM芯片

下图为1K×1位的存储芯片

![img](https://s2.ax1x.com/2019/11/14/MtolK1.png)

2）单管动态RAM芯片

下图为单管动态RAM芯片结构示意图

![img](https://s2.ax1x.com/2019/11/14/MtobiF.png)

（3）动态RAM时序

1）读时序

![img](https://s2.ax1x.com/2019/11/14/MtTuo8.png)

2）写时序

![img](https://s2.ax1x.com/2019/11/14/MtTgw6.png)

//记得根据示意图以及课本解析，看懂静态RAM基本电路的读/写操作过程、Intel2114RAM矩阵（64×64）读/写操作过程、静态RAM的读/写操作过程、三管动态RAM芯片的读/写操作过程、单管动态RAM芯片的读/写操作过程以及静态RAM和动态RAM的读/写时序，如果还没有看懂，不要急着向下哦~

（4）动态RAM的刷新

刷新：先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。

刷新周期（再生周期）：规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2ms，这个时间称为刷新周期，又称再生周期。

1）集中刷新

集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。

时间分配图：

![img](https://s2.ax1x.com/2019/11/14/MtzMxf.png)

2）分散刷新

分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。

不存在死区；存取周期长；系统速度降低。

时间分配图：

![img](https://s2.ax1x.com/2019/11/14/MtzLWt.png)

3）异步刷新

异步刷新是前两种方式的结合，既可缩短“死时间”，又充分利用最大刷新间隔为2ms的特点。

时间分布图：

![img](https://s2.ax1x.com/2019/11/14/MNp84s.png)

//这三种刷新方式很重要，一定要配合课本的（86-87页）文字解析，搞懂三种刷新的时间过程。

3、动态RAM与静态RAM的比较

动态RAM的应用比静态RAM广泛：

①在同样大小的芯片中，动态RAM的集成度远高于静态RAM。

②动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸页减少。

③动态RAM的功耗比静态RAM小。

④动态RAM的价格比静态RAM的价格便宜。

动态RAM也有缺点：

①由于使用动态元件（电容），因此它的速度比静态RAM低。

②动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。

### 4.2.4 只读存储器

对半导体ROM而言，基本器件为两种：MOS型和TTL型。

1、掩模ROM

下图为MOS型掩模ROM，容量为1K×1位，采用重合法驱动。

![img](https://s2.ax1x.com/2019/11/19/MgrdtP.png)

> 行、列地址线分别经行、列译码器，各有32行、列选择线。

> 行选择线和列选择线交叉处既有耦合元件MOS管，也可没有。

> 列选择线各控制一个列控制管，32个列控制管的输出端共连一个放大器。

2、PROM

PROM是可以实现**一次性编程**的只读存储器。

下图示意一个有双极型电路和熔丝构成的基本单元电路。

![img](https://s2.ax1x.com/2019/11/19/Mgrc0s.png)

> 在这个电路中，基极由行线控制，发射极与列线之间形成一条镍铬合金薄膜制成的熔丝（可用光刻技术实现），集电极接电源 Vcc 。熔丝断和未断可区别所存信息是“1”或“0”。

下图是由上图所示的基本单元电路构成的16 × 1位双极型镍铬熔丝式PROM芯片。用户在使用前，可按需将信息存入行、列交叉的耦合元件内。

![img](https://s2.ax1x.com/2019/11/19/MgyRzT.png)

3、EPROM

EPROM是一种可擦除可编程只读存储器，它可以由用户对其所存信息作任意次的改写。

下图为2716型EPROM的逻辑图和引脚图。

![img](https://s2.ax1x.com/2019/11/19/Mg2QfI.png)

这类芯片的外引脚除地址线、数据线外，还有两个电源引出头Vcc和Vpp。

其中Vcc接+5V；Vpp平时接+5V。当其接+25V时用来完成编程。

Vss为地。

CS为片选端，读出时为低电平，编程写入时为高电平。

PD /progr是功率下降/编程输入端，在读出时为低电平。

> EPROM的改写可用两种方法：

一是用紫外线照射，但擦除时间比较长，而且不能对个别需改写的单元进行单独擦除或重写。

二是用电气方法将存储内容擦除，再重写。甚至在联机条件下，用字擦除方式或页擦除方式，既可局部擦鞋，又可全部擦写，这种EPROM就是EEPROM。

### 4.2.5 存储器与CPU的连接

1、存储容量的扩展

将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。

（1）位扩展

位扩展指增加存储字长。

例如下图所示，2片1K × 4位的芯片可组成1K × 8位的存储器。

![img](https://s1.ax1x.com/2019/11/19/MgbgHI.png)

> 图中2片2114的地址线 A9~A0、CS、WE 都分别连在一起，其中一片的数据线作为高4位 D7~D4,另一片的数据线作为低四位D3 ~ D0 。这样便构成了一个1K × 8位的存储器。

又如下图所示，将8片16K × 1位的存储芯片连接，可组成一个16K × 8位的存储器。

![img](https://s1.ax1x.com/2019/11/19/Mgb7uj.png)

(注意，画图时不需要将所有连线画出或者所有位写出，只需画出首尾的几根或写出首尾的几个，中间用省略号表示，如上述例子中所示。)

（2）字扩展

字扩展指增加存储器字的数量。

例如下图，用2片1K × 8位的存储芯片可组成一个2K × 8位的存储器，即存储字增加了一倍。

![img](https://s1.ax1x.com/2019/11/19/M2yA7d.png)

> 在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K × 8位芯片；当A10为低电平时，反相后CS1有效，选中右边的1K × 8位芯片。右上角为反相器。

（3）字、位扩展

字、位扩展是既增加存储字的数量，又增加存储字长。

例如下图，是用8片1K × 4位的芯片组成4K × 8位的存储器。

![img](https://s1.ax1x.com/2019/11/19/M26yqg.png)

> 由图可见，每2片构成一组1K × 8位的存储器。地址线A11、A10经片选译码器得到四个片选信号CS0、CS1、CS2、CS3，分别选择其中1K × 8位的存储芯片。WE为读/写控制信号。

（画图时如果存储芯片数量过多，不必将所有芯片画出，画出部分芯片代表整体即可）

（字扩展和位扩展属于考试重点，一定要自己搞清楚原理并且动手画图）

2、存储器与CPU的连接

存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。

（1）地址线的连接

存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线多。

通常总是将**CPU地址线的低位**与存储芯片的地址线相连，**CPU地址线的高位**或在存储芯片扩充时用，或用作其他用途，如片选信号等。

> 例如，设CPU地址线为16位A15 ~ A0,1K × 4位的存储芯片仅有10根地址线A9 ~ A0。此时，可将CPU的低位地址A9 ~ A0与存储芯片地址线A9 ~ A0相连。又如，当用16K × 1位存储芯片时，则其地址线由14根A13 ~ A0，此时可将CPU的低位地址A13~ A0与存储芯片地址线A13 ~ A0相连。

（2）数据线的连接

CPU的数据线数与存储芯片的数据线数也不一定相等，此时必须对存储芯片扩位，使其**数据位数与CPU的数据线数相等**。

（3）读/写命令线的连接

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。

（4）片选线的连接

片选线的连接是CPU与存储芯片正确工作的关键。

片选有效信号与CPU的访存控制信号MREQ（低电平有效）有关。

若CPU访问I/O，则MREQ为高电平，表示不要求存储器工作。

片选有效信号还和地址有关。CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。

（5）合理选择存储芯片

存储芯片类型（RAM或ROM）和数量的选择，通常选用ROM存放系统程序、标准子程序和各类常数等，RAM则是为用户编程而设置的。

**`存储器与CPU连接的解题思路`**

分析用多少芯片完成存储系统

​         ↓

   计算芯片的地址线

​         ↓

   字选完成片内寻址

（确定多少CPU地址线直接连接到存储芯片）

​         ↓

   是否全译码方式

​         ↓

确定片选方式（把地址线的高位与译码芯片相连）

（请结合课本94-97页的习题例4.1和例4.2理解解题方式，并能独立解出存储器与CPU连接的习题）

### 4.2.6 存储器的校验

在计算机运行过程中，大量的数据需要存储，难免会出现错误。为了及时发现错误和改正错误，通常将数据配成汉明编码。

#### 4.2.6.1 汉明码的组成

汉明码具有一位纠错能力。

> **编码的最小距离：**

在一种编码系统中，任意两组合法代码之间的最少二进制位数的差异。

根据纠错理论得：

L−1=D+C  且D ≥ C

也就是编码距离 L 越大，检测错误位数 D 越大，纠正错误的位数 C 越大，而且检错能力恒大于等于纠错能力。因此，如果在信息编码中增加若干检测位，就能显著提高检错纠错能力。

（1）检测位位数k的确定

假设检测的二进制代码位数为 n 位，需要加入 k 位检测位，组成n+k位代码。为准确检测、定位错误，k 应满足：

2k≥n+k+1

例如，一段含4位2进制数的编码，需要至少3位检测位。

（2）检测位位置的确定

k 的位数确定后，接下来设定它们在传送代码中的位置。

> 注意：

对于一段n+k位的代码，在讨论检测位的位置及取值时，我们有两种编号方式。一种为自左向右编号为第1，2，3，…n+k 位；另一种为自右向左编号。两者的校验本质是一致的，只是形式不同。在此节中，我们采用授课老师采用的自右向左编号的方式，即第二种。

设 n+k位代码自右至左依次编为第1,2,3,…n+k位，而将k位检测位记作 Ci, ( i =1,2,4,…2k−1），分别安插在 n+k位代码编号的第1,2,4,…，2k−1位上。

例如，我们要传递的信息为A4A3A2A1(即n=4)，根据2k≥n+k+1易知k=3,则n+k位编码如下：

| 二进制序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 名称       | A4   | A3   | A2   | C4   | A1   | C2   | C1   |

（3）检测位检测任务的确定

检测位位置的设置是为了保证它们能承担n+k位信息中不同“小组”的奇偶检测任务，具体分配如下:

C1 检测的g1小组包含第1,3,5,7,9,11…位。

C2 检测的g2小组包含第2,3,6,7,10,11,14,15…位。

C4 检测的g4小组包含第4,5,6,7,12,13,14,15…位。

C8 检测的g8小组包含第8,9,10,11,12,13,14,15,24…位。

…

那么这些小组是如何划分的呢？

- 每个小组gi有且仅有一位为它所独占,即gi小组独占第2i−1位( i=1,2,3,···)。
- 每两个小组gi和gj共同占有一位是其他小组没有的，即每两小组gi和gj共同占有第2i−1+2j−1位( i,j=1,2,3,···)。
- 每三个小组gi,gj和gl共同占有第2i−1+2j−1+2l−1位( i,j=1,2,3,···) ,是其他小组没有的。
- 依次类推，便可确定每组所包含的各位。

**小技巧**：

例如，我们要传递的信息为A4A3A2A1，n+k位编码如下：

| 二进制序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 名称       | A4   | A3   | A2   | C4   | A1   | C2   | C1   |

A4的序号为7，按权展开为：4,2,1

A3的序号为6，按权展开为：4,2

A2的序号为5，按权展开为：4,1

A1的序号为3，按权展开为：2,1

接下来，分析各检测位的小组包含的位：

对于 C4 即寻找**含权为4**的数据位：A4,A3,A2（即第5,6,7位）

对于 C2 即寻找**含权为2**的数据位：A4,A3,A1（即第3,6,7位）

对于 C1 即寻找**含权为1**的数据位：A4,A2,A1（即第3,5,7位）

（未标明检测位自身所在的位）

（4）检测位取值的确定

仍以（2）中的例子为例，令A4A3A2A1=0101，则：

| 二进制序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 名称       | 0    | 1    | 0    | C4   | 1    | C2   | C1   |

检测位的取值为“检测任务小组”内各位的异或：

C4=A4⨁A3⨁A2=0⨁1⨁0=1

C2=A4⨁A3⨁A1=0⨁1⨁1=0

C1=A4⨁A2⨁A1=0⨁0⨁1=1

故0101的汉明码应为A4A3A2C4A1C2C1，即0101101。

> 读者会发现，这个编码与教材书上同为0101的例子，而产生汉明码为0100101不一致，这是因为我们的编号顺序与教材不一致，想必读者已经体会到了**说明编号规则**的重要性。

#### 4.2.6.2 汉明码的纠错过程

汉明码的纠错过程实际上是对传递后的编码形成新的检测位，根据新的检测位就可以得知传递过程是否产生错误，错误在哪一位。记新的检测位为Pi,Pi的状态是由原检测位Ci及其所在的小组内各位异或产生。

P4=C4⨁A4⨁A3⨁A2

P2=C2⨁A4⨁A3⨁A1

P1=C1⨁A4⨁A2⨁A1

以前例为例：

| 二进制序号 | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 名称       | 0    | 1    | 0    | 1    | 1    | 0    | 1    |

假设传递后的信息如上，那么：

P4=C4⨁A4⨁A3⨁A2=1⨁0⨁1⨁0=0

P2=C2⨁A4⨁A3⨁A1=0⨁0⨁1⨁1=0

P1=C1⨁A4⨁A2⨁A1=1⨁0⨁0⨁1=0

根据配偶原则，传递后形成的新检测位全为 0 表示传递没有出错。

反之，假设收到的传递后的编码为

| 二进制序号 | 7    | 6    | 5    | 4    | 3    | 2             | 1    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ------------- | ---- |
| 名称       | 0    | 1    | 0    | 1    | 1    | 1（此位出错） | 1    |

此时新的检测位取值为：

P4=C4⨁A4⨁A3⨁A2=1⨁0⨁1⨁0=0

P2=C2⨁A4⨁A3⨁A1=1⨁0⨁1⨁1=1（非0）

P1=C1⨁A4⨁A2⨁A1=1⨁0⨁0⨁1=0

P2出错，意味着C2,A4,A3,A1中有出错，又结合P4 P1没有出错，分析知是C2出错，将其改正即得到正确的传递结果。

> 小技巧：

P4P2P1的值为010,读者有没有发现这个数看作二进制正好是2！事实上，这个一个可行的结论，P4P2P1传入“38译码器”，输出端Y0表示传递正确，Y1至Y7对应第1~7位出错。

> 提醒：

本节我们采用的是自右向左的编号方式，相信读者理解本节后，对于教材的另一种编号方式下的汉明码，也能够轻松学会。

## 4.3 高速缓冲存储器

### 4.3.1 概述

1、问题的提出

为什么我们需要高速缓冲存储器（Cache）呢？

原因有二：

- CPU与主存之间加一级缓存，主存可将CPU需要的信息提前送至缓存，在主存与I/O设备交换时，CPU可以直接从缓存读取信息，不必等待而影响效率。
- 由于主存速度的提高始终跟不上CPU的发展，高速缓存Cache可以解决主存与CPU速度不匹配的问题。

那么，我们的设想是否可能呢？

通过分析发现，在一段时间内，CPU从主存取指令或者取数据时只是对主存局部区域的访问。这是由于指令和数据在主存内都是连续存放的，不是随机的，而是相对的簇聚，这就使得CPU在执行程序时，访存具有相对的局部性，这就称为**程序访问的局部性原理**。

根据这一原理，只要将CPU近期要用到的程序和数据提前从主存送到Cache，那么就可以实现CPU在一定时间内只访问Cache而无须访问主存。

2、Cache的工作原理

下图是Cache-主存存储空间的基本结构图

[![M22GrT.png](https://s1.ax1x.com/2019/11/19/M22GrT.png)](https://imgchr.com/i/M22GrT)

分析：

设主存由2n个可编址的字组成，每个字有唯一的n位地址。为了将容量远大于缓存的主存与缓存建立映射关系，将主存和缓存都分成若干字块，每个字块内有若干字，并使得字块一样大（即含有同样多的字）。这样设置的目的是便于在需要时将主存的某个字块整体调入Cache区，也就是基于前面提到的**程序访问的局部性原理**的考虑。

如此，主存和Cache的地址都发生了变化。在寻找地址时，需要先找“字块”，再在字块内找“字”。故，地址分为两部分。对于主存：高m位表示主存的块地址，低b位表示块内地址，则2m=M表示主存的块数。同理，缓存的高c位表示缓存的块地址，低b位表示块内地址，则2c=C表示缓存块数，易知C远小于M。主存和缓存都用b位表示块内地址，即B=2b反映了块的大小，称B为**块长**。

由于主存容量远大于缓存容量（主存块数远大于缓存块数），因此，一个缓存块不可能惟一地、永久地只对应一个主存块，故每个缓存需要设一个标记以表示当前存放的事哪一个主存块，该标记的内容**相当于主存块的编号**。

注意：

- 任何时刻都有一些主存块位于缓存块中。
- 若CPU想读取的主存的某个字已在Cache中，则直接访问Cache（CPU与Cache之间通常一次传送一个字，即字传送）。
- 而如果CPU想读取的某个字不在Cache中，此时需要将该字所在的字块整体一次调入Cache中（字块传送）。

**命中与不命中：**

上述“注意”第二条称为“CPU访问Cache命中”，第三条称为“CPU访问Cache不命中”。CPU读取信息时，将主存地址的高m位（或m位的一部分）与缓存块的标记进行比较，以判断所读的信息是否已经在缓存中。

**命中率：**

Cache的容量与块长是影响Cache效率的重要因素。通常用**命中率**来衡量**Cache的效率**。在一个程序执行期间，设Nc为访问 Cache的总命中次数,Nm为访问主存的总次数，则命中率h为:

h=Nc+NmNc

设tc为命中时的Cache访问时间，tm为未命中时的主存访问时间，1−h表示未命中率，则Cache-主存系统的平均访问时间t:

ta=htc+(1−h)tm

用e表示访存效率，则有：

e=tatc×100%=htc+(1−h)tmtc×100%

3、Cache的基本结构

Cache的基本结构如下图：

[![M22JqU.md.png](https://s1.ax1x.com/2019/11/19/M22JqU.md.png)](https://imgchr.com/i/M22JqU)

分析：

它主要由Cache存储体、地址映射变换机构、 Cache替换机构几大模块组成。

1. Cache存储体以块为单位与主存交换信息。

1. 地址映射变换机构是将CPU送来的主存地址转换为Cache地址。

如果转换后的Cache块已与CPU欲访问的主存块建立了对应关系，即已命中，则CPU直接访问Cache。否则，CPU不仅将该字从主存取出，同时将它所在的主存块一并调入Cache。在调入时，若Cache处于未被装满的状态则调入。反之就得采用替换策略。

1. 当Cache已满，无法接受来自主存块的信息时，就由替换机构按一定的替换算法来确定移出哪个块返回主存，把新的主存块调入。

1. Cache的读写操作

读操作如下图所示：

[![M228MV.md.png](https://s1.ax1x.com/2019/11/19/M228MV.md.png)](https://imgchr.com/i/M228MV)

写操作比较复杂，因为对Cache块内写入信息，本质是对其对应的主存块相应位置的信息的改写，必须与被映射的主存块内的信息完全一致。因此会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下两种方法：

- 写直达法（Write-through）
  又称存直达法（Store-through），即进行写操作时，既写入缓存又写入主存。易知，这种方法随时保证主存与缓存的数据一致性，但同时该方法增加了访存次数。
- 写回法（Write-back）
  又称拷回法（Copy-back）。它的原理是进行写操作时，只把数据写入缓存，仅当Cache中的数据被替换出去时才写入主存。容易理解写回法Cache中的数据会和主存中的不一致。为了解决这个问题，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（未被修改过，与主存一致）和“浊”（被修改过，与主存不一致）。如此，在Cache替换时，“清”的块不必写回主存，因为此时Cache中的数据与主存中是一致的，在写Cache时，将标志位设为“浊”，替换时将此Cache块写回主存，同时置为“清”。

两种方法各有特点。写直达法中。读操作时不涉及对主存的写操作，更新策略比较容易实现。在写操作中，既要写入Cache又要写入主存，因此写直达法的“写”操作时间就是访问主存的时间。写回法中读操作Cache失效发生数据替换时，被替换的块需写回主存，增加了Cache的复杂性。这种方法对主存的写操作只发生在块替换时，而且对Cache中的一个块的多次写操作只需要一次写入主存，故可减少写操作次数。“写”操作时只写入Cache，故“写”操作时间就是访问Cache的时间，因此速度快。

4、Cache的改进

1. 增加 Cache 的级数

1. 统一缓存和分立缓存的选用

参看课本[^1] P114。

### 4.3.2 Cache——主存地址映射

由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系）、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。

1、直接映射

下图反映了直接映射方式中主存与缓存的对应关系

[![M22di9.png](https://s1.ax1x.com/2019/11/19/M22di9.png)](https://imgchr.com/i/M22di9)

要点：

1. 图中每个主存块只和一个缓存块建立对应关系，映射关系式为：

i=j  mod C 或 i=j mod 2c

其中，i为缓存块号，j为主存块号，C为缓存块数。

1. 每个缓存块对应于若干个主存块。

1. 主存地址被分成三部分：低b位是指Cache的块内地址，与缓存字块大小有关。中间c位为字块地址。高 t位是指主存字块标记，它被记录在建立了对应关系的缓存块的”标记”位中。

1. 当缓存接到CPU送来的主存地址，根据中间c位找到相应的Cache字块，将字块的“标记”与主存地址的高t位相符判断。若符合且有效位为“1”(**有效位**用来识别Cache块中的数据是否有效，因为有时Cache中的数据是无效的），表示该Cache块己和主存的某块建立了对应关系，则可根据b位块内地址从Cache块中取得数据；若不符合（或有效位为“0”），则从主存读入新的字块来替代旧的字块，同时将信息送往CPU,并修改 Cache“标记”，将有效位置于“1”。

直接映射的缺点：

1.不够灵活，每个主存块只能“固定地”对应某个缓存块，会出现某时某缓存空着的情况，使缓存的存储空间得不到充分的利用。

2.如果程序要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，降低命中率。

> 例题：

假设主存容量为512KB，Cache容量为4KB，每个字块为16个字，每个字32位。请画出直接映射方式下主存地址各字段位数示意图。

答：

根据 Cache容量为4KB(212=4K),Cache地址为12位。由每字32位（即每个字 4 B）知Cache共有4KB/4B=1 K字。因每个字块16个字，故Cache中有1K/16 = 64块。

在直接映射方式下，主存地址字段的各段分配如下图所示。[![M22wGR.png](https://s1.ax1x.com/2019/11/19/M22wGR.png)](https://imgchr.com/i/M22wGR)

其中字块内地址为6位(4位表示16个字，2位表示每字 4字节），缓存共64块，故字块地址为6位，主存字块标记为主存地址长度与Cache地址长度之差 ，即19-12=7位。

2、全相联映射

下图反映了全相联映射方式中主存与缓存的对应关系：

[![M2ffJJ.png](https://s1.ax1x.com/2019/11/19/M2ffJJ.png)](https://imgchr.com/i/M2ffJJ)

要点：

1. 全相联映射允许主存中**每一字块**映射到Cache中的**任何一块**位置上。

1. 这种映射方式可以从已被占满的Cache中替换出任一旧字块。

1. 与直接映射相比，它的主存字块标记从 t位增加到 t+C位，这就使“标记”的位数增多，而且访问 Cache 时主存字块标记需要和Cache的 **全部“标记”** 位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。

1. 这种映射方式灵活，命中率也更高，缩小了块冲突率。但所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。

3、组相联映射

下图反映了组相联映射方式中主存与缓存的对应关系：

[![M220R1.png](https://s1.ax1x.com/2019/11/19/M220R1.png)](https://imgchr.com/i/M220R1)

要点：

1. 组相联映射是对直接映射和全相联映射的一种折衷。主存块映射Cache的“组”时相当于直接映射，Cache“组”内的后续对应相当于全相联映射。

1. Cache字块地址字段由直接映射中的c位变为组地址字段q位，且q=c−r, 其中2c,表示Cache的总块数，2q表示Cache的分组个数 ，2r表示每组内包含的块数。主存字块标记字段由直接映射的t 位变为s=t+r位。

1. 假设Cache分为Q组，每组有R块，则有如下关系：

i=j mod Q

其中，i为缓存的组号，j为主存的块号。某一主存块按模Q映射到缓存的第i组内。

1. 显然，主存的第j块会映射到Cache的第i组内，两者**一一对应**，属于直接映射关系；另一方面，主存的第j块可以映射到Cache的**第i组内中的任一块** ，这又体现出全相联映射关系。

1. 可见，组相联映射的性能及其复杂性介于直接映射和全相联映射两者之间，当r=0 时是直接映射方式，当 r=c 时是全相联映射方式。

举个例子：

- 假设 c=5,q=4, 则 r=c−q=1 。其实际含义为：Cache共有 2c=32个字块，共分为2q=16 组，每组内包含21=2 块。组内2块的组相联映射又称为**二路组相联**。
- 根据假设，组相联映射的含义是：主存的某一字块可以按模16映射到Cache某组的任一字块中。即主存的第0,16,32…字块可以映射到Cache第0组的2个字块中的任一字块；主存的第15,31,47…字块可以映射到Cache第15组中的任一字块。

> 例题：
> 假设主存容量为512K×16位，Cache容量为4K×16位，块长为 4 个 16 位的字，访存地址为字地址。在二路组相联映射方式下，设计主存的地址格式。
> 答：
> 每个字 16 位，Cache共4K字，每块 4 个字,块内地址需要 2 位。共1K个字块，由二路组相联的条件，一组内有 2 块，得Cache共分 512 组，即组地址需要 9 位。主存字块标记为 19 - 9 - 2 = 8 位，其地址格式如下图所示：
> [![M22Bxx.png](https://s1.ax1x.com/2019/11/19/M22Bxx.png)](https://imgchr.com/i/M22Bxx)

### 4.3.3 替换策略

前面我们提到，当我们需要将主存块调入缓存块但是相应的位置被占用了时，就需要进行数据的替换，因此产生了替换策略的问题。在直接映射中，由于某个主存块只与一个固定的Cache字块有映射关系，因此替换策略很简单。而在组相联和全相联映射中，主存块可以写入Cache中若干位置，就产生了“替换哪个Cache字块更好？”的问题，即所谓**替换算法问题**。常用的替换算法**有先进先出算法**、**近期最少使用算法**和**随机法**。

1、先进先出（First-In-First-Out，FIFO）算法

FIFO 算法选择最早调入 Cache 的字块进行替换，容易实现，开销小，但没有根据访存的局部性原理，故不能提高 Cache 的命中率。

2、近期最少使用(Least Recently Used, LRU)算法

LRU 算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU 算法的平均命中率比FIFO高。

3、随机法

随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，它也没有根据访存的局部性原理，故不能提高 Cache 的命中率。

## 4.4 辅助存储器

辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存——辅存层次。

这一部分作为扩展内容，读者可根据情况自行阅读。

参看课本P123。