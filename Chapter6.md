---
title: 第6章
description: 是description呀
---

# 第6章 计算机的运算方法

### 本章概述

符号数，原补码以及加减法运算

## 6.1 无符号数和有符号数

计算机中的数均放在寄存器中，通常称 **寄存器的位数** 为 **机器字长**。

### 6.1.1 无符号数

无符号数，指的是没有符号的数，也就是说寄存器中的每一位都可以用来存放数值。

因为没有符号，所以 8 位寄存器可以存放28=256范围大小的数字，即 0 ～ 255。同理，16 位寄存器可以存放216=65536范围大小的数字，即 0 ～ 65535。

[HTML展示](./interactive.html)

![tree-736885_960_720](img/tree-736885_960_720.webp "webp图像")

比如[这个](./example.py)文件，下载之后运行即可。

### 6.1.2 有符号数

有符号数与无符号数恰好相反，在存放有符号数的时候，要在寄存器中留出对应的位来存放正负符号。

#### 6.1.2.1 机器数与真值

计算机通常用 “0” 表示 “正”，用 “1” 表示 “负”，从而将符号数字化并保存在寄存器中。

我们将符号放在 **有效数字** 的前面，就组成了 **有符号数**。

例如：`+1100` 在机器中就表示为 `01100`，而`-1100` 在机器中就表示为 `11100`。

#### 6.1.2.2 原码表示法

**对于整数**：[x]原={0,x2n−x0≤x<2n−2n<x≤0其中，x 为真值，n 为整数的位数。注意，在上述公式中，逗号是用来隔开符号位和数值位的形式。

比如：当真值x=+1110时，[x]原=0,1110，当x=−1110时，[x]原=24−(−1110)=1,1110。

**对于小数**：[x]原={x1−x0≤x<1−1<x≤0其中，x 为真值，n 为小数的位数。

比如：当真值x=0.1101时，[x]原=0.1101，当x=−0.1101时，[x]原=1−(−0.1101)=1.1101。

原码的特点：简单、直观，但是在计算机中实现其加减法不方便。

#### 6.1.2.3 补码表示法

(1) 补的概念

补这个概念在时钟里面非常常见。例如在时钟里面想要从 6 点拨到 9 点，那么既可以顺时针拨 3 小时（+3），也可以逆时针拨 15 小时（-15），那么就可以得到：“+9 是 -3 以12为模的补数”，记作−3≡+9(mod12)，也可以称作“对模 12 而言，-3 和 -9 是互为补数的”。

注意以下要点：

- 一个负数可用它的正补数来替代，而这个正补数可以用模加上负数本身求得。
- 一个正数和一个负数互为补数时，他们绝对值之和即为模数。
- 正数的补数即该正数本身。

(2) 补码的定义

**对于整数**：[x]补={0,x2n+1+x0≤x<2n−2n<x≤0(mod2n+1)其中，x 为真值，n 为整数的位数。

比如：当真值x=+1010时，[x]补=0,1010，当x=−1101时，[x]补=24+1−1101=10000−1101=1,0011。

**对于小数**：[x]补={x2+x0≤x<1−1<x≤0(mod2)其中，x 为真值，n 为小数的位数。

比如：当真值x=0.1001时，[x]补=0.1001，当x=−0.0110时，[x]补=210+0.10012=10.00002−0.01102=1.1010。

证明可得[+0]补=[−0]补=0.0000，即 “零” 的表示形式只有一种。

符号位的长度与模数有关。例如当模数为 4 时，又形成了双符号位的补码，如x=−0.1001，对(mod22)而言，[x]补=22+x=100.0000−0.1001=11.0111。

> **小技巧1**：当真值为负时，补码可用 **原码除符号位外，每位取反**，末位加 1 求得。

> **小技巧2**：还有一种简单的计算方案：

> 假设有一个数的原码是 `1,0001010101011101011110000`，想算补码，那么我们首先从右往左一个一个找，找什么呢？找第一次出现的 “1”。在本例子中，“1” 出现在 **从右往左数** 第 5 位。

> 现在不要眨眼，我们从右侧第 6 位开始，把后面 **除了符号位以外** 的东西全部 **按位取反**，得到`1,1110101010100010100010000`，这就是我们要的补码！！！！！！

> 验证一下，看看真的是这样吗？小数也是这样吗？请读者自行验证。

#### 6.1.2.4 反码表示法

**对于整数**：[x]反={0,x(2n+1−1)+x0≤x<2n−2n<x≤0(mod(2n+1−1))其中，x 为真值，n 为整数的位数。

比如：当真值x=+1101时，[x]反=0,1101，当x=−1101时，[x]反=24+1−1+1101=1,0010。

**对于小数**：[x]反={x(2−2−n)+x0≤x<1−1<x≤0其中，x 为真值，n 为小数的位数。

比如：当真值x=0.0110时，[x]反=0.0110，当x=−0.0110时，[x]反=(2−2−4)−0.0110=1.1001。

综上所述，三种机器数的特点：

- 三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”（对于小数）或“,”（对于整数）隔开。
- 当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，而数值部分与真值相同。
- 当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”。

#### 6.1.2.5 移码表示法

由于补码带有符号位很难直接判断真值大小，因此需要想办法把数字处理一下，这样计算机进行大小比较的时候就可以把符号位也当作一个正常的数字位进行比较了。

移码的定义为：[x]移=2n+x(−2n≤x<2n)，其中，x为真值，n为整数的位数。

比如：当真值x=10100时，[x]移=1,10100，当x=−10100时，[x]移=25−10100=0,01100。

并且，[+0]移=[−0]移=1,00000，是唯一的。

另外，同一个真值的移码和补码仅差一个符号位，因此只需要将补码的符号位由“0”修改为“1”，或者从“1”修改为“0”，即可得到移码。

## 6.2 数的定点表示和浮点表示

### 6.2.1 定点表示

小数点固定在某一位置的数称为定点数，有以下两种表示方式：

![MMPwtO.png](https://s2.ax1x.com/2019/11/11/MMPwtO.png "这里是图片的标题测试测试测试")

当小数点位于数符和第一数值位之间时（如上如左），机器内的数为纯小数；当小数点位于数值位之后时（如上如右），机器内的数为纯整数。

另外，采用定点数的机器称为定点机。数值部分的位数 n 决定了定点机中数的表示范围。在定点机中，由于小数点的位置固定不变，因此当机器处理的数不是纯小数或纯整数时，必须乘一个比例因子，否则会造成“溢出”。

### 6.2.2 浮点表示

浮点数的通常表示方式：N=S×rj，其中，S 为尾数（小数，可正可负），j 为阶码（整数，可正可负），r 是基数（或者基值）。在计算机中，r 常取 2，4，8，16 等。

#### 6.2.2.1 浮点数的表示形式

浮点数在机器中的表示形式如下图所示。采用这种数据格式的机器称为浮点机。

![MMP0hD.png](https://s2.ax1x.com/2019/11/11/MMP0hD.png)

其中，记阶码数值部分的位数为 m，尾数数值部分的位数为 n。则在浮点数中：

- m 反映了浮点数的表示范围以及小数点的实际位置
- n 反映了浮点数的精度
  -Sf​代表浮点数的符号

整个浮点数可以被看作是两个数的结合，前一个阶码是整数，后一个尾数是小数。

#### 6.2.2.2 浮点数的表示范围

以浮点数通式N=S×rj为例，设浮点数阶码的数值位取 m 位，尾数的数值位取 n 位，当浮点数为非规格化数*时，它在数轴上的表示范围如下图所示：

> *对于某些过小的数，如`1.23e-130`，允许的阶数位数不能满足阶数大小的需要，这时可能就会在尾数前添加前导“0”，如将其表示为`0.000123e-126`，这样的数就是非规格化数。

![MMPWAf.png](https://s2.ax1x.com/2019/11/11/MMPWAf.png)

阶码和尾数的分配将会直接影响浮点数的表示范围和精度。通常来讲：

- 对于短实数（总位数32位）：阶码 8 位（含阶符 1 位），尾数 24 位（含数符 1 位）
- 对于长实数（总位数64位）：阶码 11 位（含阶符 1 位），尾数 53 位（含数符 1 位）
- 对于临时实数（总位数80位）：阶码 15 位（含阶符 1 位），尾数 65 位（含数符 1 位）

#### 6.2.2.3 浮点数的规格化形式

尾数变为规格化数能够提高浮点数的精度（能够减少计算过程中出现 0 或者 NaN 的可能性）。

通过修改阶码并左右移位尾数的方法，可以使非规格化数变为规格化数，这个过程称为 **规格化**。规格化数的 **形式** 和规格化的 **过程** 对于 **基数不同** 的浮点数是不同的。例如在浮点数通式N=S×rj中：

-r=2时，尾数最高位为 1 的数为规格化数。规格化时，尾数左移 1 位，阶码减 1（该过程称为向左规格化，简称 **左规**）；尾数右移 1 位，阶码加 1（该过程称为向右规格化，简称 **右规**）。

-r=4时，尾数最高两位不全为 0 的数为规格化数。规格化时，尾数左移 2 位，阶码减 1；尾数右移 2 位，阶码加 1。

-r=8时，尾数最高三位不全为 0 的数为规格化数。规格化时，尾数左移 3 位，阶码减 1；尾数右移 3 位，阶码加 1。

r 更大的规格化同理。

在浮点机中，一旦基数确定后就不再变了。由于基数并不体现在浮点数的存储中（基数是隐含的），所以不同基数的浮点数表示完全相同。

一般来说，基数 r 越大：

- 可表示的浮点数范围越大，所表示的数个数越多
- 浮点数的精度越低

### 6.2.3 定点数和浮点数的比较

- 当浮点机和定点机中数的位数相同时，浮点数的表示范围比定点数的大得多。
- 当浮点数为规格化数时，其相对精度远比定点数高。
- 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。
- 在溢出的判断方法上，浮点数是对规格化数的阶吗进行判断，而定点数是对数值本身进行判断。

总之，浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。但在运算规则、运算速度及硬件成本方面又不如定点数。因此，究竟选用定点数还是浮点数应根据具体应用综合考虑。

一般来说，通用的大型计算机大多采用浮点数，或同时采用定、浮点数；小型、微型及某些专用机、控制机则大多采用定点数。

## 6.3 定点运算

### 6.3.1 移位运算

#### 6.3.1.1 移位的意义

例如在生活中，15m 可以写成 1500cm，从数字而言，1500 相当于 15 相对于小数点左移了两位（同时补充了“0”）；15 相当于 1500 向右移了两位（同时删掉了多余的“0”）。

从本质上来说，左移的过程使得数的绝对值扩大，右移使得绝对值缩小。

对于二进制计算机来说，左移或右移 n 位相当于乘以或者除以2n(n=1,2,...,n)。

另外，由于移位后会出现空缺，因此补充空缺到底是用 0 还是 1，与机器采用有符号数还是无符号数有关。

#### 6.3.1.2 算数移位

有符号数的移位称为算数移位。

算数移位的规则如下：

![img](https://s2.ax1x.com/2019/12/29/lunISI.png)

注意算数移位的重要特点：**不论是正数还是负数，移位后其符号位均不变**。

另外，从表格我们可以得出的结论：

- 机器数为正时，不论是左移还是右移，添补代码均为 0。
- 由于负数的原码数值部分与真值相同，所以在移位时只需要使符号位不变，其余空位均添 0 即可。
- 由于负数的反码各位除符号位以外与负数的原码正好相反，所以移位后所添的代码应与原码相反，即全部添 1。
- 分析任意数的补码发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位与对应的反码相同，而在此“1”右边的各位（包括“1”本身）与对应的原码相同。所以负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0；右移时因空位出现在高位，则添补的代码与反码相同，即添 1。

关于位移以后的结果：

- 对于正数，三种机器数移位后符号位均不变，左移时最高数位丢 1，结果出错；右移时最低数位丢 1，影响精度。
- 对于负数，三种机器数移位后符号位均不变;
- 负数的原码左移时最高数位丢 1，结果出错；右移时最低数位丢 1，影响精度。
- 负数的补码左移时最高数位丢 0，结果出错；右移时最低数位丢 1，影响精度。
- 负数的反码左移时最高数位丢 0，结果出错；右移时最低数位丢 0，影响精度。

下图为实现算数左移右移的硬件框图：

![MMPD9e.png](https://s2.ax1x.com/2019/11/11/MMPD9e.png)

另外，为了避免算数移位时丢失数据，可以采用带进位（Cy）的移位，示意图如下（下图是左移）：

![MMPscd.png](https://s2.ax1x.com/2019/11/11/MMPscd.png)

#### 6.3.1.3 逻辑移位

无符号数的移位称为逻辑移位。

规则：逻辑左移时，高位移丢，低位添 0；逻辑右移时，低位移丢，高位添 0。

### 6.3.2 加减法运算

加减法运算是计算机中最基本的运算。由于减法运算可以通过加负值的方式代替，所以加减法被放在一起进行讨论。

#### 6.3.2.1 补码加减运算的基本公式

对于整数：[A]补+[B]补=[A+B]补(mod2n+1)[A−B]补=[A]补+[−B]补(mod2n+1)

对于小数：[A]补+[B]补=[A+B]补(mod2)[A−B]补=[A]补+[−B]补(mod2)

#### 6.3.2.2 溢出判断

(1) 用一位符号判断溢出

不论作加法还是作减法，只要实际参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，结果又与原操作数的符号不同，即为溢出。

计算机中采用这种方法进行判断时，通常用 **符号位产生的进位** 与 **最高有效位产生的进位** 异或操作后，按其结果进行判断。若异或结果为 1，即为1溢出；异或结果为 0，则无溢出。

(2) 用两位符号位判断溢出

2 位符号位的补码，即 **变形补码**，是以 4 为模的，其定义为：[x]补′={x4+x0≤x<1−1≤x<0(mod4)用变形补码作加法时，2 位符号位要连同数值部分一起参加运算，而且高位符号位产生的进位自动丢失，便可得正确结果，即[x]补′+[y]补′=[x+y]补′变形补码判断溢出的原则是：当 2 位符号位不同时，表示溢出，否则，无溢出。

**注意**：无论是否发生溢出，高位（从左到右第 1 位）符号位永远代表真正的符号。

另外，采用双符号位方案时，寄存器或主存中的操作数只需要保留一位符号位即可。

#### 6.3.2.3 补码定点加减法所需的硬件配置

![MMPyjA.png](https://s2.ax1x.com/2019/11/11/MMPyjA.png)

图中，寄存器A、X、加法器的位数相等，其中A存放被加数（或被减数）的补码，X存放加数（或减数）的补码。

当作减法时，由“求补控制逻辑”将X送至加法器，并使加法器的最末位来进位为 1，以达到对减数求补的目的。

运算结果溢出时，通过溢出判断电路置“1”溢出标记V。GA为加法标记，GS为减法标记。

### 6.3.3 乘法运算

#### 6.3.3.1 笔算乘法改进

计算过程：

1. 乘法运算可用移位和假发来实现，两个 n 位数相乘，总共需要进行 n 次加法运算和 n 次加法移位。

1. 由乘数的末位值确定被乘数是否与原部分积想家，然后右移一位，形成新的部分积，同时，乘数也右移移位，由次低位作新的末位，空出最高位放部分积的最低位。

1. 每次作加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。

这样做对计算机的好处：计算机很容易实现这种运算规则。一个寄存器放被乘数，一个寄存器存放乘积的高位，另一个寄存器放乘数及乘积的低位，再配上加法器和其他电路，即可构成乘法器。而加法只在部分积高位进行，所以不仅节省了器材，而且缩短运算时间。

#### 6.3.3.2 原码乘法

由于原码与真值的表示只差一个符号，因此可以直接使用上述的讨论结果，再加以符号位处理即可。

(1) 原码一位乘运算规则

原码一位乘的运算规则如下：

1. 乘积的符号位由两位原码符号位异或运算结果决定。

1. 乘积的数值部分由两数绝对值相乘，其通式为：

![img](https://s2.ax1x.com/2019/12/29/lunzpn.png)，再令zi表示第 i 次部分积，则上式可写成如下递推公式：

![img](https://s2.ax1x.com/2019/12/29/luuAk4.png)

注意，由于乘积的数值部分是 **两数绝对值** 相乘的结果，故原码一位乘法运算过程中的右移操作均为 **逻辑右移**。

(2) 原码一位乘所需的硬件配置

![MMPgBt.png](https://s2.ax1x.com/2019/11/11/MMPgBt.png)

图中，A、X、Q均为n+1位的寄存器，其中X存放被乘数的原码，Q存放乘数的原码。移位和加控制电路受末位乘数Qn的控制（当Qn=1时，A和X内容相加后，A、Q右移一位；当Qn=0时，只作A、Q右移一位的操作）。计数器C用于控制逐位相乘的次数。S存放乘积的符号。GM为乘法标记。

(3) 原码两位乘

原码两位乘与原码一位乘一样，符号位的运算和数值部分是分开进行的，但原码两位乘是用两位乘数来决定新的部分积如何形成，因此可以提高运算速度。

两位乘数的四种状态如下：

| 乘数yn−1yn | 新的部分积                                  |
| ---------- | ------------------------------------------- |
| 0 0        | 新部分积等于原部分积右移两位                |
| 0 1        | 新部分积等于原部分积加被乘数后右移两位      |
| 1 0        | 新部分积等于原部分积加 2 倍被乘数后右移两位 |
| 1 1        | 新部分积等于原部分积加 3 倍被乘数后右移两位 |

由于在计算机中获得 3 倍被乘数比较困难，因此将乘以 3 分两步完成，第一步先完成减 1 倍被乘数的操作，第二步完成加 4 倍被乘数的操作。而加 4 倍被乘数的操作实际上是由比“11”高的两位乘数代替完成的，可以看作是在高两位乘数上加“1”，这个“1”可以暂存在Cj触发器中。机器完成Cj置“1”，即意味着对高两位乘数加 1，也即要求高两位乘数代替本两位乘数“11”来完成加 4 倍被乘数的操作。

由此可得原码两位乘运算规则：

| 乘数判断位yn−1yn | 标志位Cj | 操作内容                         |
| ---------------- | -------- | -------------------------------- |
| 0 0              | 0        | z→ 2 位，y∗→ 2 位，Cj保持“0”     |
| 0 1              | 0        | z+x∗→ 2 位，y∗→ 2 位，Cj保持“0”  |
| 1 0              | 0        | z+2x∗→ 2 位，y∗→ 2 位，Cj保持“0” |
| 1 1              | 0        | z−x∗→ 2 位，y∗→ 2 位，Cj置“1”    |
| 0 0              | 1        | z+x∗→ 2 位，y∗→ 2 位，Cj置“0”    |
| 0 1              | 1        | z+2x∗→ 2 位，y∗→ 2 位，Cj置“0”   |
| 1 0              | 1        | z−x∗→ 2 位，y∗→ 2 位，Cj保持“1”  |
| 1 1              | 1        | z→ 2 位，y∗→ 2 位，Cj保持“1”     |

表中，z表示原有部分积，x∗表示被乘数的绝对值，y∗表示乘数的绝对值， → 2 表示右移两位。当进行−x∗运算时，一般都采用加[−x∗]补来实现。这样，参与原码两位乘运算的操作数是绝对值的补码，因此运算中右移两位的操作也必须按补码右移规则完成。尤其注意的是，乘法过程中可能要加 2 倍被乘数，即+[2x∗]补，使部分积的绝对值大于 2。为此，只有对部分积取 3 位符号位，且以最高符号位作为真正的符号位，才能保证运算过程的正确无误。

此外，为了统一用两位乘数和一位Cj共同配合管理全部操作，与原码一位乘不同的是，需要在乘数（当乘数位数为偶数时）的最高位前增加两个 0。这样，当乘数最高两个有效位出现“11”时，需将Cj置“1”，再与所添补的两个 0 结合呈 001 状态，以完成加x∗的操作（此步不必移位）。

#### 6.3.3.3 补码乘法

(1) 补码一位乘运算规则

设被乘数[x]补=x0.x1x2⋯xn

乘数[y]补=y0.y1y2⋯xn

1. 被乘数 x 符号任意，乘数 y 符号位正：

[x⋅y]补=[x]补⋅[y]补=[x]补⋅y对照原码一位乘的两个表达式，可见当乘数 y 为正数时，不管被乘数 x 符号如何1，都可以按照原码乘法的规则运算，即![img](https://s2.ax1x.com/2019/12/29/luQm1s.png)

1. 被乘数 x 符号任意，乘数 y 符号为负：

[x⋅y]补=[x]补(0.y1y2⋯yn)+[−x]补由此可得，当乘数为负时是把乘数的补码[y]补去掉符号位，当成一个正数与[x]补相乘，然后加上[−x]补进行校正，也称校正法，用递推公式表示如下：![img](https://s2.ax1x.com/2019/12/29/lultIS.png)

1. 被乘数 x 和乘数 y 符号均为任意

比较法是 Booth 夫妇首先提出来的，又叫 Booth 算法。

按照补码乘法校正法规则，其基本算法可用一个统一的公式表示为[x⋅y]补=[x]补(0.y1y2⋯yn)−[x]补⋅y0，其递推公式为![img](https://s2.ax1x.com/2019/12/29/luQrND.png)

(2) 补码比较法（Booth 算法）所需的硬件配置

![MMP2HP.png](https://s2.ax1x.com/2019/11/11/MMP2HP.png)

图中A、X、Q均为n+2位寄存器，其中X存放被乘数的补码（含两位符号位），Q存放乘数的补码（含最高 1 位符号位和最末 1 位附加位），移位和加控制逻辑受Q寄存器末 2 位乘数控制。当其为 01 时，A、X内容相加后A、Q右移一位；当其为 10 时，A、X内容相减后A、Q右移一位。计数器C用于控制逐位相乘的次数，GM为乘法标记。

## 6.4 浮点四则运算

经过6.2的学习之后，我们已经对浮点数有了一定的了解，在6.4中我们将会介绍浮点数的四则运算（主要是加减）。

### 6.4.1 浮点加减

现在假设我们有两个浮点数

x=sx∗rjx

y=sy∗rjy

而当二者的阶码不等时，由于小数点位置不同，所以无法直接进行加减运算。所以浮点数的加减通常按照以下步骤进行：

1. 对阶

1. 尾数求和

1. 规格化

1. 舍入

1. 溢出判断

**对阶**

对阶的目的是小阶向大阶看齐，所以阶小的尾数向右位移，每右移一位，阶码+1，至相等为止。但可能会丢失数码影响精度。

例（参见原书270页）：

x=0.1101∗201

y=(−0.1010∗211)

求x+y

进行加法前，需先进行对阶，求出阶差

[Δj]补=[ix]补−[jy]补=00,01+11,01=11,10

求出阶码之后，按小阶向大阶看齐的原则，将x的尾数右移两位，则对阶完毕。

**尾数求和**

只需按定点数的运算规则进行运算即可

**规格化**

当尾数求和（差）的结果不满足双符号位补码规格化的形式时，就需要规格化。规格化分左规和右规。

- 左规

```
使用条件：尾数出现00.0xxx……x或11.1xxx……x时。尾数左移一位，阶码减一，直至符合00.1xxx……x或11.0xxx……x时。
```

- 右规

```
使用条件： 尾数出现01.xxx……x或10.xxx……x时。在定点运算时算作溢出，但在浮点运算时，只需尾数右移一位，阶码+1即可处理
```

**舍入**

在对阶和右规的过程中，可能会丢失尾数，影响精度，使用用舍入法提高精度。

- “0舍1入”法

```
若被移去的最高位是0，则舍去（+0），若最高位是1，则末尾+1.但可能使尾数仍然溢出，此时需要再做一次右规。所以又可以理解为，舍去谁就加谁。
```

- “恒置1”法

```
不论移去的最高位是0还是1，始终让右移后的尾数恒置1.但也同样存在使尾数变大变小的两种可能。
```

**溢出判断**

浮点机的溢出由阶码的符号决定：

[j]补=01,xx……x时为上溢；[j]补=10,xx……x时为下溢，按机器零处理。

